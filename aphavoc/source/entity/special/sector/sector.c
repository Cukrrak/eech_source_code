// 
// 	 Enemy Engaged RAH-66 Comanche Versus KA-52 Hokum
// 	 Copyright (C) 2000 Empire Interactive (Europe) Ltd,
// 	 677 High Road, North Finchley, London N12 0DA
// 
// 	 Please see the document LICENSE.TXT for the full licence agreement
// 
// 2. LICENCE
//  2.1 	
//  	Subject to the provisions of this Agreement we now grant to you the 
//  	following rights in respect of the Source Code:
//   2.1.1 
//   	the non-exclusive right to Exploit  the Source Code and Executable 
//   	Code on any medium; and 
//   2.1.2 
//   	the non-exclusive right to create and distribute Derivative Works.
//  2.2 	
//  	Subject to the provisions of this Agreement we now grant you the
// 	following rights in respect of the Object Code:
//   2.2.1 
// 	the non-exclusive right to Exploit the Object Code on the same
// 	terms and conditions set out in clause 3, provided that any
// 	distribution is done so on the terms of this Agreement and is
// 	accompanied by the Source Code and Executable Code (as
// 	applicable).
// 
// 3. GENERAL OBLIGATIONS
//  3.1 
//  	In consideration of the licence granted in clause 2.1 you now agree:
//   3.1.1 
// 	that when you distribute the Source Code or Executable Code or
// 	any Derivative Works to Recipients you will also include the
// 	terms of this Agreement;
//   3.1.2 
// 	that when you make the Source Code, Executable Code or any
// 	Derivative Works ("Materials") available to download, you will
// 	ensure that Recipients must accept the terms of this Agreement
// 	before being allowed to download such Materials;
//   3.1.3 
// 	that by Exploiting the Source Code or Executable Code you may
// 	not impose any further restrictions on a Recipient's subsequent
// 	Exploitation of the Source Code or Executable Code other than
// 	those contained in the terms and conditions of this Agreement;
//   3.1.4 
// 	not (and not to allow any third party) to profit or make any
// 	charge for the Source Code, or Executable Code, any
// 	Exploitation of the Source Code or Executable Code, or for any
// 	Derivative Works;
//   3.1.5 
// 	not to place any restrictions on the operability of the Source 
// 	Code;
//   3.1.6 
// 	to attach prominent notices to any Derivative Works stating
// 	that you have changed the Source Code or Executable Code and to
// 	include the details anddate of such change; and
//   3.1.7 
//   	not to Exploit the Source Code or Executable Code otherwise than
// 	as expressly permitted by  this Agreement.
// 



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "project.h"

#include "ai/highlevl/highlevl.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define DEBUG_MODULE 0

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

entity
	**entity_sector_map = NULL;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

const char
	*null_sector_entity_map_pointer_message = "NULL sector entity in entity_sector_map";

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void play_sector_air_defences_sighted_speech (entity *en, entity *sector_en);

void play_sector_keysite_sighted_speech (entity *en, entity *sector_en, entity *target_keysite);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

entity *get_local_sector_entity (vec3d *pos)
{
	entity
		*en;

	int
		x_sec,
		z_sec;

	ASSERT (pos);

	if (!point_inside_map_area (pos))
	{
		debug_fatal ("Position off map: (x = %f, z = %f)", pos->x, pos->z);
	}

	get_x_sector (x_sec, pos->x);
	get_z_sector (z_sec, pos->z);

	en = get_local_raw_sector_entity(x_sec, z_sec);

	ASSERT (en);

	return (en);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static float get_local_sector_entity_enemy_defence_level (float *array, entity_sides side)
{
	int
		loop;

	float
		defence_level;

	loop = ENTITY_SIDE_NEUTRAL;

	defence_level = 0;

	while (++ loop < NUM_ENTITY_SIDES)
	{

		if (side == loop)
		{

			continue;
		}

		defence_level += array [loop];
	}

	return defence_level;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float get_local_sector_entity_enemy_surface_to_air_defence_level (entity *sector_en, entity_sides side)
{
	sector
		*raw;

	raw = (sector *) get_local_entity_data (sector_en);

	return get_local_sector_entity_enemy_defence_level (raw->surface_to_air_defence_level, side);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float get_local_sector_entity_enemy_surface_to_surface_defence_level (entity *sector_en, entity_sides side)
{
	sector
		*raw;

	raw = (sector *) get_local_entity_data (sector_en);

	return get_local_sector_entity_enemy_defence_level (raw->surface_to_surface_defence_level, side);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float get_sector_importance_level (int sx, int sz, entity_sides side)
{
	entity
		*en;

	sector
		*raw;
		
	ASSERT (get_comms_model () == COMMS_MODEL_SERVER);

	en = get_local_raw_sector_entity (sx, sz);

	ASSERT (en);

	raw = (sector *) get_local_entity_data (en);

	return raw->importance_level [side];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float get_sector_distance_to_friendly_base (int sx, int sz, entity_sides side)
{
	entity
		*en;

	sector
		*raw;
		
	ASSERT (get_comms_model () == COMMS_MODEL_SERVER);

	en = get_local_raw_sector_entity (sx, sz);

	ASSERT (en);

	raw = (sector *) get_local_entity_data (en);

	return raw->distance_to_friendly_base [side];
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void add_mobile_values_to_sector (entity *sector_en, entity *mobile_en)
{
	ASSERT (sector_en);

	ASSERT (mobile_en);

	if (get_comms_model () != COMMS_MODEL_SERVER)
	{
		return;
	}

	if (get_local_entity_int_value (mobile_en, INT_TYPE_ALIVE))
	{
		if (get_local_entity_int_value (mobile_en, INT_TYPE_IDENTIFY_VEHICLE))
		{
			// surface to air threat

			update_imap_surface_to_air_defence_level (mobile_en, sector_en, TRUE);

			// surface to surface threat

			update_imap_surface_to_surface_defence_level (mobile_en, sector_en, TRUE);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void remove_mobile_values_from_sector (entity *sector_en, entity *mobile_en)
{
	ASSERT (sector_en);

	ASSERT (mobile_en);

	if (get_comms_model () != COMMS_MODEL_SERVER)
	{
		return;
	}

	if (get_local_entity_int_value (mobile_en, INT_TYPE_ALIVE))
	{
		if (get_local_entity_int_value (mobile_en, INT_TYPE_IDENTIFY_VEHICLE))
		{
			// surface to air threat

			update_imap_surface_to_air_defence_level (mobile_en, sector_en, FALSE);

			// surface to surface threat

			update_imap_surface_to_surface_defence_level (mobile_en, sector_en, FALSE);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float get_local_sector_side_ratio (int sx, int sz, entity_sides side)
{
	float
		ratio,
		total;

	sector
		*raw;

	entity
		*en;

	en = get_local_raw_sector_entity (sx, sz);

	ASSERT (en);

	raw = (sector *) get_local_entity_data (en);

	total = raw->sector_side [ENTITY_SIDE_BLUE_FORCE] + raw->sector_side [ENTITY_SIDE_RED_FORCE];

	ASSERT (total > 0.0);

	ratio = raw->sector_side [side] / total;

	return ratio;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void validate_local_sector_entities (void)
{
	int
		x_sector,
		z_sector,
		entity_x_sector,
		entity_z_sector;

	vec3d
		*position;

	entity
		*sec,
		*en;

	for (x_sector = 0; x_sector < NUM_MAP_X_SECTORS; x_sector++)
	{
		for (z_sector = 0; z_sector < NUM_MAP_Z_SECTORS; z_sector++)
		{
			sec = get_local_raw_sector_entity (x_sector, z_sector);

			en = get_local_entity_first_child (sec, LIST_TYPE_SECTOR);

			while (en)
			{
				position = get_local_entity_vec3d_ptr (en, VEC3D_TYPE_POSITION);

				get_x_sector (entity_x_sector, position->x);
				get_z_sector (entity_z_sector, position->z);

				if ((entity_x_sector != x_sector) || (entity_z_sector != z_sector))
				{
					debug_fatal ("Entity is in the wrong sector (type = %s)", get_local_entity_type_name (en));
				}

				en = get_local_entity_child_succ (en, LIST_TYPE_SECTOR);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_sector_fog_of_war_value (entity *en, entity *sector_en)
{
	entity
		*sec,
		*group;

	float
		r,
		recon_radius,
		maximum_value;

	entity_sides
		side;

	sector
		*sector_raw;

	int
		x, z,
		sx, sz,
		min_x, min_z,
		max_x, max_z,
		sector_radius;

	float
		new_fog_value,
		current_fog_value;

	vec3d
		*pos,
		sector_pos;

	ASSERT (en);

	ASSERT (sector_en);

	if (!get_session_entity ())
	{
		return;
	}

	if (!get_local_entity_int_value (en, INT_TYPE_ALIVE))
	{
		return;
	}

	side = (entity_sides) get_local_entity_int_value (en, INT_TYPE_SIDE);

	group = get_local_entity_parent (en, LIST_TYPE_MEMBER);

	maximum_value = get_local_entity_float_value (get_session_entity (), FLOAT_TYPE_FOG_OF_WAR_MAXIMUM_VALUE);

	//
	// set surrounding sectors awareness
	//

	pos = get_local_entity_vec3d_ptr (en, VEC3D_TYPE_POSITION);

	ASSERT (pos);

	recon_radius = get_local_entity_float_value (en, FLOAT_TYPE_RECON_RADIUS) * 2.0;

	convert_float_to_int (recon_radius, &sector_radius);

	sector_radius /= SECTOR_SIDE_LENGTH;

	sector_radius += 1;

	sx = get_local_entity_int_value (sector_en, INT_TYPE_X_SECTOR);
	sz = get_local_entity_int_value (sector_en, INT_TYPE_Z_SECTOR);

	min_x = bound (sx - sector_radius, MIN_MAP_X_SECTOR, MAX_MAP_X_SECTOR);
	min_z = bound (sz - sector_radius, MIN_MAP_Z_SECTOR, MAX_MAP_Z_SECTOR);

	max_x = bound (sx + sector_radius, MIN_MAP_X_SECTOR, MAX_MAP_X_SECTOR);
	max_z = bound (sz + sector_radius, MIN_MAP_Z_SECTOR, MAX_MAP_Z_SECTOR);

	sector_pos.y = 0.0;
	sector_pos.z = (min_z * SECTOR_SIDE_LENGTH) + (SECTOR_SIDE_LENGTH / 2);

	for (z = min_z; z <= max_z; z++)
	{

		sector_pos.x = (min_x * SECTOR_SIDE_LENGTH) - (SECTOR_SIDE_LENGTH / 2);

		for (x = min_x; x <= max_x; x++)
		{

			sector_pos.x += SECTOR_SIDE_LENGTH;

			//
			// get sector data
			//

			sec = get_local_raw_sector_entity(x, z);

			sector_raw = (sector *) get_local_entity_data (sec);

			current_fog_value = sector_raw->fog_of_war [side];

			//
			// set sector awareness timer
			//
			
			if ((z == sz) && (x == sx))
			{
				new_fog_value = maximum_value;
			}
			else
			{	
				new_fog_value = current_fog_value;

				r = get_approx_3d_range (&sector_pos, pos);

				if (r <= recon_radius)
				{
					new_fog_value = max (current_fog_value, ((1.0f - (r / recon_radius)) * maximum_value));
				}
			}

			ASSERT (new_fog_value >= current_fog_value);
				
			if (new_fog_value > current_fog_value)
			{
				sector_raw->fog_of_war [side] = new_fog_value;
			}
		}

		sector_pos.z += SECTOR_SIDE_LENGTH;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float get_sector_fog_of_war_value (entity *en, entity_sides side)
{
	sector
		*raw;
		
	ASSERT (en);

	raw = (sector *) get_local_entity_data (en);

	if (get_local_entity_int_value (en, INT_TYPE_SECTOR_SIDE) == side)
	{
		return get_local_entity_float_value (get_session_entity (), FLOAT_TYPE_FOG_OF_WAR_MAXIMUM_VALUE);
	}
	else
	{
		return raw->fog_of_war [side];
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void update_sector_fog_of_war (void)
{
	entity
		*sec;

	sector
		*raw;

	int
		x, z;

	for (z = NUM_MAP_Z_SECTORS - 1; z >= 0; z --)
	{
		for (x = NUM_MAP_X_SECTORS - 1; x >= 0; x --)
		{
			sec = get_local_raw_sector_entity (x, z);

			raw = (sector *) get_local_entity_data (sec);

			raw->fog_of_war [ENTITY_SIDE_BLUE_FORCE] = max (0.0, raw->fog_of_war [ENTITY_SIDE_BLUE_FORCE] - FOG_OF_WAR_DECAY_RATE);
			raw->fog_of_war [ENTITY_SIDE_RED_FORCE] = max (0.0, raw->fog_of_war [ENTITY_SIDE_RED_FORCE] - FOG_OF_WAR_DECAY_RATE);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void update_client_server_sector_fog_of_war (void)
{
	debug_log ("SECTOR: Start update sector fog of war");

	ASSERT (get_comms_model () == COMMS_MODEL_SERVER);

	update_sector_fog_of_war ();

	transmit_entity_comms_message (ENTITY_COMMS_UPDATE_FOG_OF_WAR, NULL);

	debug_log ("SECTOR: End update sector fog of war");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void update_sector_side_count (void)
{
	entity
		*sec,
		*force_entity [NUM_ENTITY_SIDES];

	int
		x, z,
		side,
		count [NUM_ENTITY_SIDES];

	for (side = 0; side < NUM_ENTITY_SIDES; side ++)
	{
		count [side] = 0;

		force_entity [side] = get_local_force_entity ((entity_sides) side);
	}

	for (z = NUM_MAP_Z_SECTORS - 1; z >= 0; z --)
	{
		for (x = NUM_MAP_X_SECTORS - 1; x >= 0; x --)
		{
			sec = get_local_raw_sector_entity (x, z);

			side = get_local_entity_int_value (sec, INT_TYPE_SECTOR_SIDE);

			count [side] ++;
		}
	}

	for (side = 0; side < NUM_ENTITY_SIDES; side ++)
	{
		if (force_entity [side])
		{
			set_local_entity_int_value (force_entity [side], INT_TYPE_FORCE_SECTOR_COUNT, count [side]);
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void update_client_server_sector_side_count (void)
{
	debug_log ("SECTOR: Start update sector sides");

	ASSERT (get_comms_model () == COMMS_MODEL_SERVER);

	update_sector_side_count ();

	transmit_entity_comms_message (ENTITY_COMMS_UPDATE_SECTOR_SIDE_COUNT, NULL);

	debug_log ("SECTOR: End update sector sides");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int get_sector_task_type_count (entity *en, entity_sub_types task_type, entity_sides side)
{
	entity
		*task_en;

	int
		count;

	ASSERT (en);

	ASSERT (en->type == ENTITY_TYPE_SECTOR);

	count = 0;

	task_en = get_local_entity_first_child (en, LIST_TYPE_SECTOR_TASK);

	while (task_en)
	{
		if (get_local_entity_int_value (task_en, INT_TYPE_ENTITY_SUB_TYPE) == task_type)
		{
			if (get_local_entity_int_value (task_en, INT_TYPE_SIDE) == side)
			{
				count ++;
			}
		}

		task_en = get_local_entity_child_succ (task_en, LIST_TYPE_SECTOR_TASK);
	}

	#if DEBUG_MODULE
	{
		sector
			*raw;
			
		raw = (sector *) get_local_entity_data (en);
		
		debug_log ("SECTOR : %d tasks of type %s in sector %d, %d",
						count,
						task_database [task_type].full_name,
						raw->x_sector,
						raw->z_sector
					 );
	}
	#endif

	return count;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void play_sector_air_defences_sighted_speech (entity *en, entity *sector_en)
{
	if (get_local_entity_int_value (en, INT_TYPE_IDENTIFY_AIRCRAFT))
	{
		if (get_local_entity_int_value (en, INT_TYPE_PLAYER) != ENTITY_PLAYER_AI)
		{
			//
			// PLAY_SPEECH (CPG)
			//
		}
		else
		{
			//
			// PLAY_SPEECH (WINGMAN)
			//
		}
	}
	else
	{
		//
		// PLAY_SPEECH (GC)
		//
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void play_sector_keysite_sighted_speech (entity *en, entity *sector_en, entity *target_keysite)
{
	if (get_local_entity_int_value (en, INT_TYPE_IDENTIFY_AIRCRAFT))
	{
		if (get_local_entity_int_value (en, INT_TYPE_PLAYER) != ENTITY_PLAYER_AI)
		{
			// PLAY_SPEECH (CPG)
			//
		}
		else
		{
			//
			// PLAY_SPEECH (WINGMAN)
			//
		}
	}
	else
	{
		//
		// PLAY_SPEECH (GC)
		//
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
