// 
// 	 Enemy Engaged RAH-66 Comanche Versus KA-52 Hokum
// 	 Copyright (C) 2000 Empire Interactive (Europe) Ltd,
// 	 677 High Road, North Finchley, London N12 0DA
// 
// 	 Please see the document LICENSE.TXT for the full licence agreement
// 
// 2. LICENCE
//  2.1 	
//  	Subject to the provisions of this Agreement we now grant to you the 
//  	following rights in respect of the Source Code:
//   2.1.1 
//   	the non-exclusive right to Exploit  the Source Code and Executable 
//   	Code on any medium; and 
//   2.1.2 
//   	the non-exclusive right to create and distribute Derivative Works.
//  2.2 	
//  	Subject to the provisions of this Agreement we now grant you the
// 	following rights in respect of the Object Code:
//   2.2.1 
// 	the non-exclusive right to Exploit the Object Code on the same
// 	terms and conditions set out in clause 3, provided that any
// 	distribution is done so on the terms of this Agreement and is
// 	accompanied by the Source Code and Executable Code (as
// 	applicable).
// 
// 3. GENERAL OBLIGATIONS
//  3.1 
//  	In consideration of the licence granted in clause 2.1 you now agree:
//   3.1.1 
// 	that when you distribute the Source Code or Executable Code or
// 	any Derivative Works to Recipients you will also include the
// 	terms of this Agreement;
//   3.1.2 
// 	that when you make the Source Code, Executable Code or any
// 	Derivative Works ("Materials") available to download, you will
// 	ensure that Recipients must accept the terms of this Agreement
// 	before being allowed to download such Materials;
//   3.1.3 
// 	that by Exploiting the Source Code or Executable Code you may
// 	not impose any further restrictions on a Recipient's subsequent
// 	Exploitation of the Source Code or Executable Code other than
// 	those contained in the terms and conditions of this Agreement;
//   3.1.4 
// 	not (and not to allow any third party) to profit or make any
// 	charge for the Source Code, or Executable Code, any
// 	Exploitation of the Source Code or Executable Code, or for any
// 	Derivative Works;
//   3.1.5 
// 	not to place any restrictions on the operability of the Source 
// 	Code;
//   3.1.6 
// 	to attach prominent notices to any Derivative Works stating
// 	that you have changed the Source Code or Executable Code and to
// 	include the details anddate of such change; and
//   3.1.7 
//   	not to Exploit the Source Code or Executable Code otherwise than
// 	as expressly permitted by  this Agreement.
// 



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define INTERNAL_MODULES 1

#include "userint2.h"

#include "graphics.h"

#include "misc.h"

#include "3d.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define DEBUG_USERINT 0

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void
	((*ui_user_function) (void)) = NULL;

int
	lock_object_capture = FALSE,
	((*ui_user_redraw_function) (void)) = NULL;

static int
	exit_ui = FALSE,
	ui_redraw = TRUE;

static event
	ui_last_event;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ui_object
	*root_object = NULL,
	*left_captured_object,
	*right_captured_object,
	**captured_object,
	*highlighted_object;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void
	((*mouse_button_function) (ui_object *obj, void *arg));

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int ui_check_ui_object_under_mouse ( ui_object *obj, int mouse_x, int mouse_y );

static void ui_mouse_button_down (void);

static void ui_mouse_button_up (void);

static void call_function (ui_object *obj, void *arg);

static void call_right_function (ui_object *obj, void *arg);

static void do_highlighting (void);

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ui_object_manager (void)
{

	ASSERT (get_ui_installed ());

	ASSERT (root_object);

	push_ui_screen (root_object);

	highlighted_object = NULL;

   while (!exit_ui)
   {

      process_events ();

		do_highlighting ();

		ui_repaint ();

		system_sleep (0);

		set_ui_redraw (FALSE);

		if (ui_user_function)
		{

			ui_user_function ();
		}

		set_delta_time ();
   }

	ui_repaint ();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ui_repaint (void)
{

	int
		x,
		y;

	x = get_mouse_x ();
	y = get_mouse_y ();

	clear_zbuffer_screen ();

	update_ui_screen_stack ();

	draw_raw_mouse_pointer (x, y);

	ddraw_flip_surface ();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ui_set_root_object (ui_object *new_root)
{

	root_object = new_root;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ui_object *ui_get_root_object (void)
{

	return root_object;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_ui_redraw (int flag)
{

	ui_redraw = flag;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int get_ui_redraw (void)
{

	return ui_redraw;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

ui_object *check_ui_object_for_selection (ui_object *obj, int mouse_x, int mouse_y)
{

	ui_object
		*selected_object;

	selected_object = NULL;

	while (get_ui_object_next (obj))
	{

		obj = get_ui_object_next (obj);
	}

	while ((obj) && (!ui_check_ui_object_under_mouse (obj, mouse_x, mouse_y)))
	{

		obj = get_ui_object_prev (obj);
	}

	if (obj)
	{

		ui_object
			*child;

		child = get_ui_object_child (obj);

		if (child)
		{
	
			selected_object = check_ui_object_for_selection (child, mouse_x, mouse_y);
		}

		if (!selected_object)
		{

			return obj;
		}
	}

	return selected_object;
}

/*
{

	if (next)
	{

		selected_object = check_ui_object_for_selection (next, mouse_x, mouse_y);
	}

	return (selected_object);

	if (!get_ui_object_drawable (obj))
	{

		if (next)
		{

			return check_ui_object_for_selection (next, mouse_x, mouse_y);
		}
		else
		{

			return selected_object;
		}
	}

	if ((!selected_object) && (get_ui_object_drawable (obj)) && (get_ui_object_notify_on (obj) != NOTIFY_TYPE_NONE))
	{

		ui_object
			*parent_obj;

		float
			parent_x = 0,
			parent_y = 0,
			x1,
			y1,
			x2,
			y2;
	
		parent_obj = get_ui_object_parent (obj);
	
		if (parent_obj)
		{
				
			parent_x = get_ui_object_x_origin (parent_obj);
		
			parent_y = get_ui_object_y_origin (parent_obj);
		}
	
		x1 = get_ui_object_x (obj) + parent_x;
	
		y1 = get_ui_object_y (obj) + parent_y;
	
		x2 = x1 + get_ui_object_x_size (obj);
	
		y2 = y1 + get_ui_object_y_size (obj);

		if ((mouse_x > x1) && (mouse_x < x2))
		{
	
			if (((mouse_y + MOUSE_Y_OFFSET) > y1) && ((mouse_y + MOUSE_Y_OFFSET) < y2))
			{

				//#if DEBUG_USERINT
				{

					char
						buffer [1024];

					sprintf (buffer, "UI_MAN OBJECT SELECTION: within object %s (%f,%f, %f,%f) against mouse %d,%d", get_ui_object_text (obj), x1, y1, x2, y2, mouse_x, mouse_y);
					//OutputDebugString (buffer);

					//debug_log ("UI_MAN OBJECT SELECTION: within object %s (%f,%f, %f,%f) against mouse %d,%d", get_ui_object_text (obj), x1, y1, x2, y2, mouse_x, mouse_y);
				}
				//#endif

				if ((!selected_object) && (child))
				{
			
					selected_object = check_ui_object_for_selection (child, mouse_x, mouse_y);
				}

				if (!selected_object)
				{

					selected_object = obj;
				}
			}
			else
			{
				#if DEBUG_USERINT
	
				debug_log ("UI_MAN OBJECT SELECTION: outside object %s (%f,%f, %f,%f) against mouse %d,%d", get_ui_object_text (obj), x1, y1, x2, y2, mouse_x, mouse_y);
	
				#endif
			}
		}
		else
		{

			#if DEBUG_USERINT
	
			debug_log ("UI_MAN OBJECT SELECTION: outside object %s (%f,%f, %f,%f) against mouse %d,%d", get_ui_object_text (obj), x1, y1, x2, y2, mouse_x, mouse_y);
	
			#endif
		}
	}

	return selected_object;
}
*/
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int ui_check_ui_object_under_mouse ( ui_object *obj, int mouse_x, int mouse_y )
{

	ui_object
		*parent_obj;

	float
		parent_x = 0,
		parent_y = 0,
		x1,
		y1,
		x2,
		y2;

	if ((get_ui_object_drawable (obj)) && (get_ui_object_notify_on (obj) != NOTIFY_TYPE_NONE))
	{
	
		parent_obj = get_ui_object_parent (obj);
	
		if (parent_obj)
		{
				
			parent_x = get_ui_object_x_origin (parent_obj);
			parent_y = get_ui_object_y_origin (parent_obj);
		}
	
		x1 = get_ui_object_x (obj) + parent_x;
		y1 = get_ui_object_y (obj) + parent_y;
	
		x2 = x1 + get_ui_object_x_size (obj);
		y2 = y1 + get_ui_object_y_size (obj);
	
		if ((mouse_x > x1) && (mouse_x < x2))
		{
	
			if (((mouse_y + MOUSE_Y_OFFSET) > y1) && ((mouse_y + MOUSE_Y_OFFSET) < y2))
			{
	
				return ( TRUE );
			}
		}
	}

	return ( FALSE );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ui_left_mouse_button (event *ev)
{

	memcpy (&ui_last_event, ev, sizeof (event));

	mouse_button_function = call_function;

	captured_object = &left_captured_object;

	if (ev->state == BUTTON_STATE_DOWN)
	{

		#if DEBUG_USERINT

		debug_log ("USERINT: left mouse button down");

		#endif

		ui_mouse_button_down ();
	}
	else
	{
		#if DEBUG_USERINT

		debug_log ("USERINT: left mouse button up");

		#endif

		ui_mouse_button_up ();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ui_right_mouse_button (event *ev)
{

	memcpy (&ui_last_event, ev, sizeof (event));

	mouse_button_function = call_right_function;

	captured_object = &right_captured_object;

	if (ev->state == BUTTON_STATE_DOWN)
	{

		#if DEBUG_USERINT

		debug_log ("USERINT: right mouse button down");

		#endif

		ui_mouse_button_down ();
	}
	else
	{

		#if DEBUG_USERINT

		debug_log ("USERINT: right mouse button up");

		#endif

		ui_mouse_button_up ();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void call_function (ui_object *obj, void *arg)
{

	// need to do this since call_ui_object_function is a macro..

	call_ui_object_function (obj, arg);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void call_right_function (ui_object *obj, void *arg)
{

	// need to do this since call_ui_object_function is a macro..

	call_ui_object_right_function (obj, arg);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ui_mouse_button_up (void)
{

	int
		mouse_x,
		mouse_y;

	ui_object
		*current_obj,
		*this_captured_object;

	int
		state = BUTTON_STATE_UP;

	mouse_x = get_mouse_x ();

	mouse_y = get_mouse_y ();

	current_obj = get_ui_object_child (current_screen);

	if (!current_obj)
	{

		return;
	}

	this_captured_object = check_ui_object_for_selection (current_obj, mouse_x, mouse_y);

	if (lock_object_capture)
	{

		this_captured_object = *captured_object;
	}

	if (*captured_object)
	{

		if (this_captured_object)
		{

			#if DEBUG_USERINT
		
			debug_log ("USERINT: object captured = %d, at %f, %f size %f, %f", this_captured_object->type, get_ui_object_x (this_captured_object), get_ui_object_y (this_captured_object), get_ui_object_x_size (this_captured_object), get_ui_object_y_size (this_captured_object));
		
			#endif
		
			if (this_captured_object == *captured_object)
			{

				#if DEBUG_USERINT
		
				debug_log ("USERINT: calling object function");

				#endif

				mouse_button_function (*captured_object, (void *) state);
			}
			else
			{

				#if DEBUG_USERINT
		
				debug_log ("USERINT: call both object invalid_state functions");

				#endif

				state = BUTTON_STATE_INVALID;

				mouse_button_function (this_captured_object, (void *) state);

				mouse_button_function (*captured_object, (void *) state);
			}
		}
		else
		{

			#if DEBUG_USERINT
		
			debug_log ("USERINT: call object invalid_state function");

			#endif

			state = BUTTON_STATE_INVALID;

			mouse_button_function (*captured_object, (void *) state);
		}
	}

	*captured_object = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ui_mouse_button_down (void)
{

	ui_object
		*current_obj;

	int
		state = BUTTON_STATE_DOWN;

	int
		mouse_x,
		mouse_y;

	mouse_x = get_mouse_x ();

	mouse_y = get_mouse_y ();

	current_obj = get_ui_object_child (current_screen);

	if (!current_obj)
	{

		return;
	}

	*captured_object = check_ui_object_for_selection (current_obj, mouse_x, mouse_y);

	if (*captured_object)
	{

		#if DEBUG_USERINT
	
		debug_log ("USERINT: object captured = %d, at %f, %f size %f, %f", ((ui_object *)*captured_object)->type, get_ui_object_x (*captured_object), get_ui_object_y (*captured_object), get_ui_object_x_size (*captured_object), get_ui_object_y_size (*captured_object));
	
		#endif
	
		mouse_button_function (*captured_object, (void *) state);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_exit_ui (int flag)
{

	exit_ui = flag;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ui_force_update (void)
{

	#if DEBUG_USERINT

	debug_log ("UI_MAN OBJECT FORCE UPDATE: repainting screen");

	#endif

	//
	// Render to front screen
	//

	do_highlighting ();

	ui_repaint ();

	//
	//
	//

	set_ui_redraw (FALSE);

	if (ui_user_function)
	{

		ui_user_function ();
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ui_set_user_function (void (*fn) (void))
{

	ui_user_function = fn;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void ui_set_user_redraw_function (int (*fn) (void))
{

	ui_user_redraw_function = fn;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

event *get_ui_last_event (void)
{

	return &ui_last_event;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void save_ui_screen (event *arg)
{

	int
		file_count;

	char
		filename [32];

	for (file_count = 0; file_count <= 99; file_count ++)
	{

		sprintf (filename, "screen%02d.tga", file_count);

		if (!file_exist (filename))
		{

			debug_log ("Screen Shot : %s", filename);

			save_tga_screen (filename);

			return;
		}
	}

	debug_log ("Error Saving Screen: Limit exceeded");
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void do_highlighting (void)
{

	static ui_object
		*last_obj = NULL;

	int
		arg = 0;

	highlighted_object = check_ui_object_for_selection (current_screen, get_mouse_x (), get_mouse_y ());

	if (highlighted_object != last_obj)
	{

		if ((last_obj) && (get_ui_object_highlightable (last_obj)))
		{

			arg = BUTTON_STATE_UP;

			#if DEBUG_USERINT

			debug_log ("UI_MAN: setting object highlighted off. Calling highlighted function (arg %d)", arg);

			#endif

			set_ui_object_highlighted (last_obj, FALSE);

			call_ui_object_highlighted_function (last_obj, (void *) arg);
		}

		if (highlighted_object)
		{

			if (get_ui_object_highlightable (highlighted_object))
			{

				arg = BUTTON_STATE_DOWN;

				#if DEBUG_USERINT

				debug_log ("UI_MAN: setting object highlighted. Calling highlighted function (arg %d)", arg);

				#endif

				set_ui_object_highlighted (highlighted_object, TRUE);

				call_ui_object_highlighted_function (highlighted_object, (void *) arg);
			}

			set_ui_object_tool_tips_timer (highlighted_object, get_system_time () + TIME_1_SECOND);
		}

		#if DEBUG_USERINT

		debug_log ("UI_MAN: resetting tool tips");

		#endif

		reset_tool_tips ();
	}
	else if (highlighted_object)
	{

		if (get_ui_object_highlightable (highlighted_object))
		{

			if (get_ui_object_highlighted_notify_on (highlighted_object) == NOTIFY_TYPE_CONTINUAL)
			{

				call_ui_object_highlighted_function (highlighted_object, (void *) arg);
			}
		}
	}

	if (highlighted_object)
	{

		tool_tips_draw_ui_object (highlighted_object);
	}

	last_obj = highlighted_object;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
