// 
// 	 Enemy Engaged RAH-66 Comanche Versus KA-52 Hokum
// 	 Copyright (C) 2000 Empire Interactive (Europe) Ltd,
// 	 677 High Road, North Finchley, London N12 0DA
// 
// 	 Please see the document LICENSE.TXT for the full licence agreement
// 
// 2. LICENCE
//  2.1 	
//  	Subject to the provisions of this Agreement we now grant to you the 
//  	following rights in respect of the Source Code:
//   2.1.1 
//   	the non-exclusive right to Exploit  the Source Code and Executable 
//   	Code on any medium; and 
//   2.1.2 
//   	the non-exclusive right to create and distribute Derivative Works.
//  2.2 	
//  	Subject to the provisions of this Agreement we now grant you the
// 	following rights in respect of the Object Code:
//   2.2.1 
// 	the non-exclusive right to Exploit the Object Code on the same
// 	terms and conditions set out in clause 3, provided that any
// 	distribution is done so on the terms of this Agreement and is
// 	accompanied by the Source Code and Executable Code (as
// 	applicable).
// 
// 3. GENERAL OBLIGATIONS
//  3.1 
//  	In consideration of the licence granted in clause 2.1 you now agree:
//   3.1.1 
// 	that when you distribute the Source Code or Executable Code or
// 	any Derivative Works to Recipients you will also include the
// 	terms of this Agreement;
//   3.1.2 
// 	that when you make the Source Code, Executable Code or any
// 	Derivative Works ("Materials") available to download, you will
// 	ensure that Recipients must accept the terms of this Agreement
// 	before being allowed to download such Materials;
//   3.1.3 
// 	that by Exploiting the Source Code or Executable Code you may
// 	not impose any further restrictions on a Recipient's subsequent
// 	Exploitation of the Source Code or Executable Code other than
// 	those contained in the terms and conditions of this Agreement;
//   3.1.4 
// 	not (and not to allow any third party) to profit or make any
// 	charge for the Source Code, or Executable Code, any
// 	Exploitation of the Source Code or Executable Code, or for any
// 	Derivative Works;
//   3.1.5 
// 	not to place any restrictions on the operability of the Source 
// 	Code;
//   3.1.6 
// 	to attach prominent notices to any Derivative Works stating
// 	that you have changed the Source Code or Executable Code and to
// 	include the details anddate of such change; and
//   3.1.7 
//   	not to Exploit the Source Code or Executable Code otherwise than
// 	as expressly permitted by  this Agreement.
// 



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "3d.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

light_3d_source
	light_3d_array[MAX_3D_LIGHTS];

light_3d_source
	*saved_current_3d_lights,
	recoloured_light_array[MAX_TEMPORARY_3D_LIGHTS];

light_3d_source
	*current_3d_sun = NULL;

light_3d_source
	*current_3d_lights = NULL;

light_3d_source
	ambient_3d_light =
	{

		{ 0, 0, 0 },

		0.1, 0.1, 0.1, 0.1,

		1,
		LIGHT_3D_TYPE_INVALID,

		0,
		0
	};

int
	shadows_enabled;

float
	shadows_strength;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_3d_ambient_light_level ( float red, float green, float blue )
{

	ambient_3d_light.colour.red = red;
	ambient_3d_light.colour.green = green;
	ambient_3d_light.colour.blue = blue;

//	ambient_3d_light.colour.intensity = ( ( red * 0.3 ) + ( green * 0.59 ) + ( blue * 0.11 ) );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

light_3d_source * create_light_3d_source ( enum LIGHT_3D_TYPE type, int specular, vec3d *position, float radius, float red, float green, float blue )
{

	light_3d_source
		*light;

	light = safe_malloc ( sizeof ( light_3d_source ) );

	if ( light )
	{

		//
		// Dependant on the type of light, position is either the position, or the direction
		//

		light->type = type;

		light->colour.red = red;
		light->colour.green = green;
		light->colour.blue = blue;

		if ( specular )
		{

			light->intensity = ( red * 0.3 ) + ( green * 0.59 ) + ( blue * 0.11 );
		}
		else
		{

			light->intensity = 0.0;
		}

		light->light_position = *position;

		light->radius = radius;

		return ( light );
	}
	else
	{

		return ( NULL );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void destroy_light_3d_source ( light_3d_source *light )
{

	ASSERT ( light );

	safe_free ( light );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void reset_light_3d_sources_in_3d_scene ( void )
{

	current_3d_lights = NULL;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_3d_ambient_light_source ( env_3d *env, light_colour *colour )
{

	ASSERT ( env );

	env->ambient_light.red = colour->red;
	env->ambient_light.green = colour->green;
	env->ambient_light.blue = colour->blue;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_3d_main_light_source ( env_3d *env, light_colour *colour, vec3d *direction, int shadows )
{

	ASSERT ( env );

	env->main_3d_light.colour = *colour;
	env->main_3d_light.light_direction = *direction;
	env->main_3d_light.type = LIGHT_3D_TYPE_DIRECTIONAL;

	env->shadows_enabled = shadows;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void insert_light_3d_source_into_3d_scene ( light_3d_source *light )
{

	ASSERT ( light );

	if ( current_3d_lights )
	{

		light_3d_source
			*this_light,
			*last_light;

		//
		// Insert at the end of the light list
		//

		this_light = current_3d_lights;

		while ( this_light )
		{

			last_light = this_light;

			this_light = this_light->succ;
		}

		light->pred = last_light;

		light->succ = NULL;

		last_light->succ = light;
	}
	else
	{

		light->pred = NULL;

		light->succ = NULL;

		current_3d_lights = light;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void insert_main_3d_light_into_3d_scene ( light_3d_source *sun )
{

	//
	// Remove the main 3d light from the list of lights, and put it in again
	//

	remove_light_3d_source_from_3d_scene ( sun );

	if ( current_3d_lights )
	{

		sun->pred = NULL;

		sun->succ = current_3d_lights;

		current_3d_lights->pred = sun;

		current_3d_lights = sun;
	}
	else
	{

		current_3d_lights = sun;

		sun->pred = NULL;

		sun->succ = NULL;
	}

	current_3d_sun = sun;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void remove_light_3d_source_from_3d_scene ( light_3d_source *light )
{

	light_3d_source
		*this_light;

	ASSERT ( light );

	if ( current_3d_lights )
	{
	
		if ( light == current_3d_lights )
		{
	
			current_3d_lights = light->succ;
	
			light->succ = NULL;
	
			light->pred = NULL;
		}
		else
		{
		
			//
			// Go through checking the light is in the scene
			//
		
			this_light = current_3d_lights;
		
			while ( this_light )
			{
		
				if ( this_light == light )
				{
	
					//
					// The light MUST have a previous light source, as its not at the head of the lights list.
					//
	
					light->pred->succ = light->succ;
	
					if ( light->succ )
					{
	
						light->succ->pred = light->pred;
					}
			
					light->pred = NULL;
				
					light->succ = NULL;
			
					break;
				}
		
				this_light = this_light->succ;
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_light_3d_source_colour ( light_3d_source *light, float red, float green, float blue )
{

	ASSERT ( light );

	light->colour.red = red;

	light->colour.green = green;

	light->colour.blue = blue;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_light_3d_source_radius ( light_3d_source *light, float radius )
{

	ASSERT ( light );

	light->radius = radius;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void copy_and_recolour_current_3d_lights ( struct REAL_COLOUR colour )
{

	float
		red,
		green,
		blue;

	red = colour.red;
	green = colour.green;
	blue = colour.blue;

	red /= 255.0;
	green /= 255.0;
	blue /= 255.0;

	red *= 1.8666;
	green *= 1.8666;
	blue *= 1.8666;

	if ( active_3d_environment->infrared_mode == INFRARED_ON )
	{

		float
			grey;

		grey = red * 0.3 + green * 0.59 + blue + 0.11;
	
		//
		// Save the current ambient light
		//
	
		recoloured_light_array[0] = ambient_3d_light;
	
		ambient_3d_light.colour.red *= grey;
		ambient_3d_light.colour.green *= grey;
		ambient_3d_light.colour.blue *= grey;
	}
	else
	{
	
		//
		// Save the current ambient light
		//
	
		recoloured_light_array[0] = ambient_3d_light;
	
		ambient_3d_light.colour.red *= red;
		ambient_3d_light.colour.green *= green;
		ambient_3d_light.colour.blue *= blue;
	}

	if ( current_3d_lights )
	{
/*
		light_3d_source
			*lights;
	
		int
			current_recoloured_light_index;

		current_recoloured_light_index = 1;
	
		lights = current_3d_lights;

		while ( lights )
		{

			recoloured_light_array[current_recoloured_light_index] = *lights;

			recoloured_light_array[current_recoloured_light_index].colour.red *= red;
			recoloured_light_array[current_recoloured_light_index].colour.green *= green;
			recoloured_light_array[current_recoloured_light_index].colour.blue *= blue;

			recoloured_light_array[current_recoloured_light_index].pred = NULL;
			recoloured_light_array[current_recoloured_light_index].succ = NULL;

			if ( current_recoloured_light_index != 0 )
			{

				recoloured_light_array[current_recoloured_light_index].pred = &recoloured_light_array[current_recoloured_light_index-1];
				recoloured_light_array[current_recoloured_light_index-1].succ = &recoloured_light_array[current_recoloured_light_index];
			}

			lights = lights->succ;

			current_recoloured_light_index++;
		}
		*/

		saved_current_3d_lights = current_3d_lights;

//		current_3d_lights = &recoloured_light_array[1];
		current_3d_lights = NULL;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void restore_uncoloured_current_3d_lights ( void )
{

	ambient_3d_light = recoloured_light_array[0];

	current_3d_lights = saved_current_3d_lights;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

