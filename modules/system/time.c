// 
// 	 Enemy Engaged RAH-66 Comanche Versus KA-52 Hokum
// 	 Copyright (C) 2000 Empire Interactive (Europe) Ltd,
// 	 677 High Road, North Finchley, London N12 0DA
// 
// 	 Please see the document LICENSE.TXT for the full licence agreement
// 
// 2. LICENCE
//  2.1 	
//  	Subject to the provisions of this Agreement we now grant to you the 
//  	following rights in respect of the Source Code:
//   2.1.1 
//   	the non-exclusive right to Exploit  the Source Code and Executable 
//   	Code on any medium; and 
//   2.1.2 
//   	the non-exclusive right to create and distribute Derivative Works.
//  2.2 	
//  	Subject to the provisions of this Agreement we now grant you the
// 	following rights in respect of the Object Code:
//   2.2.1 
// 	the non-exclusive right to Exploit the Object Code on the same
// 	terms and conditions set out in clause 3, provided that any
// 	distribution is done so on the terms of this Agreement and is
// 	accompanied by the Source Code and Executable Code (as
// 	applicable).
// 
// 3. GENERAL OBLIGATIONS
//  3.1 
//  	In consideration of the licence granted in clause 2.1 you now agree:
//   3.1.1 
// 	that when you distribute the Source Code or Executable Code or
// 	any Derivative Works to Recipients you will also include the
// 	terms of this Agreement;
//   3.1.2 
// 	that when you make the Source Code, Executable Code or any
// 	Derivative Works ("Materials") available to download, you will
// 	ensure that Recipients must accept the terms of this Agreement
// 	before being allowed to download such Materials;
//   3.1.3 
// 	that by Exploiting the Source Code or Executable Code you may
// 	not impose any further restrictions on a Recipient's subsequent
// 	Exploitation of the Source Code or Executable Code other than
// 	those contained in the terms and conditions of this Agreement;
//   3.1.4 
// 	not (and not to allow any third party) to profit or make any
// 	charge for the Source Code, or Executable Code, any
// 	Exploitation of the Source Code or Executable Code, or for any
// 	Derivative Works;
//   3.1.5 
// 	not to place any restrictions on the operability of the Source 
// 	Code;
//   3.1.6 
// 	to attach prominent notices to any Derivative Works stating
// 	that you have changed the Source Code or Executable Code and to
// 	include the details anddate of such change; and
//   3.1.7 
//   	not to Exploit the Source Code or Executable Code otherwise than
// 	as expressly permitted by  this Agreement.
// 



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "system.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define DELTA_TIME_HISTORY_SIZE 200

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float
	system_delta_time_average = 0.1,
	system_delta_time = 0.1,
	system_one_over_delta_time = 10.0;

int
	locked_frame_rate = FALSE;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static float
	system_delta_time_history[DELTA_TIME_HISTORY_SIZE];

static int
	system_delta_time_history_position;

static DWORD
	last_time_value = 0;

static float
	locked_delta_time = 1.0 / 25.0,
	locked_one_over_delta_time = 25.0;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void reset_delta_time ( void )
{

	int
		loop;

	for ( loop = 0; loop < DELTA_TIME_HISTORY_SIZE; loop ++ )
	{

		system_delta_time_history[loop] = 0.1;
	}

	system_delta_time_history_position = 0;

	last_time_value = timeGetTime ();

	system_delta_time = 0.1;

	system_one_over_delta_time = 10.0;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_delta_time ( void )
{

	DWORD
		this_time_value,
		difference;

	if ( !locked_frame_rate )
	{

		this_time_value = timeGetTime ();

		difference = this_time_value - last_time_value;

		system_delta_time = ( ( ( float ) difference ) / 1000.0 );

		if ( system_delta_time == 0.0 )
		{

			system_delta_time = 0.001;	//1.0;

			system_one_over_delta_time = 1000.0;	//1.0 / system_delta_time;
		}
		else
		{
	
			system_one_over_delta_time = 1.0 / system_delta_time;
		}

		last_time_value = this_time_value;

		system_delta_time_history[system_delta_time_history_position] = system_delta_time;

		system_delta_time_history_position = ( ++system_delta_time_history_position ) % DELTA_TIME_HISTORY_SIZE;
	}
	else
	{

		//
		// *MUST* update the last_time_value
		//

		last_time_value = timeGetTime ();

		system_delta_time = locked_delta_time;

		system_one_over_delta_time = locked_one_over_delta_time;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

unsigned int get_system_time ( void )
{

	return ( ( unsigned int ) timeGetTime () );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

float get_delta_time_average ( void )
{

	int
		loop;

	system_delta_time_average = 0.0;

	for ( loop = 0; loop < DELTA_TIME_HISTORY_SIZE; loop ++ )
	{

		system_delta_time_average += system_delta_time_history[loop];
	}

	system_delta_time_average /= DELTA_TIME_HISTORY_SIZE;

	return ( system_delta_time_average );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void debug_watch_delta_time (void)
{

	debug_watch ( "system_delta_time					= %f", MT_FLOAT, &system_delta_time );

	debug_watch ( "system_delta_time_average%		= %f", MT_FLOAT, &system_delta_time_average );

	debug_watch ( "system_one_over_delta_time	= %f", MT_FLOAT, &system_one_over_delta_time );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int get_system_time_of_day (void)
{

	SYSTEMTIME
		time;

	int
		hours,
		minutes,
		seconds;

	GetSystemTime ( &time );

	hours = time.wHour;
	minutes = time.wMinute;
	seconds = time.wSecond;

	return ( ( hours * 60 * 60 ) + ( minutes * 60 ) + ( seconds ) );
/*
	time_t
		timer;

	struct tm
		tmbuf;

	//
	// get number of seconds past midnight
	//
	
	time ( &timer );

	_localtime ( &timer, &tmbuf );

	return ( ( tmbuf.tm_hour * 60 * 60 ) + ( tmbuf.tm_min * 60 ) + tmbuf.tm_sec );
	*/
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void get_system_date (int *day, int *month, int *year)
{
	time_t
		timer;

	struct tm
		*tmbuf;

	timer = time ( NULL );

	if ( timer != -1 )
	{

		tmbuf = gmtime ( &timer );

		if ( tmbuf )
		{
	
			*day = tmbuf->tm_mday;
	
			*month = ( tmbuf->tm_mon + 1 );
	
			*year = ( tmbuf->tm_year % 100 );

			return;
		}
	}

	debug_fatal( "Coordinated Universal Time not supported by system" );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void lock_frame_rate ( float frames_per_second )
{

	ASSERT ( frames_per_second > 0.0 );

	locked_frame_rate = TRUE;

	locked_delta_time = 1.0 / frames_per_second;

	locked_one_over_delta_time = frames_per_second;

	debug_colour_log ( DEBUG_COLOUR_RED, "Frame rate locked to %.2f frames per second", frames_per_second );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void unlock_frame_rate ( void )
{

	locked_frame_rate = FALSE;

	debug_colour_log ( DEBUG_COLOUR_BLUE, "Frame rate unlocked" );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void set_manual_delta_time (float delta_time)
{

	if (!locked_frame_rate)
	{

		system_delta_time = delta_time;

		system_one_over_delta_time = 1.0 / delta_time;

		system_delta_time_history [system_delta_time_history_position] = system_delta_time;

		system_delta_time_history_position = (++ system_delta_time_history_position) % DELTA_TIME_HISTORY_SIZE;
	}
	else
	{

		debug_log ("TIME: cannot set locked delta time");
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
