// 
// 	 Enemy Engaged RAH-66 Comanche Versus KA-52 Hokum
// 	 Copyright (C) 2000 Empire Interactive (Europe) Ltd,
// 	 677 High Road, North Finchley, London N12 0DA
// 
// 	 Please see the document LICENSE.TXT for the full licence agreement
// 
// 2. LICENCE
//  2.1 	
//  	Subject to the provisions of this Agreement we now grant to you the 
//  	following rights in respect of the Source Code:
//   2.1.1 
//   	the non-exclusive right to Exploit  the Source Code and Executable 
//   	Code on any medium; and 
//   2.1.2 
//   	the non-exclusive right to create and distribute Derivative Works.
//  2.2 	
//  	Subject to the provisions of this Agreement we now grant you the
// 	following rights in respect of the Object Code:
//   2.2.1 
// 	the non-exclusive right to Exploit the Object Code on the same
// 	terms and conditions set out in clause 3, provided that any
// 	distribution is done so on the terms of this Agreement and is
// 	accompanied by the Source Code and Executable Code (as
// 	applicable).
// 
// 3. GENERAL OBLIGATIONS
//  3.1 
//  	In consideration of the licence granted in clause 2.1 you now agree:
//   3.1.1 
// 	that when you distribute the Source Code or Executable Code or
// 	any Derivative Works to Recipients you will also include the
// 	terms of this Agreement;
//   3.1.2 
// 	that when you make the Source Code, Executable Code or any
// 	Derivative Works ("Materials") available to download, you will
// 	ensure that Recipients must accept the terms of this Agreement
// 	before being allowed to download such Materials;
//   3.1.3 
// 	that by Exploiting the Source Code or Executable Code you may
// 	not impose any further restrictions on a Recipient's subsequent
// 	Exploitation of the Source Code or Executable Code other than
// 	those contained in the terms and conditions of this Agreement;
//   3.1.4 
// 	not (and not to allow any third party) to profit or make any
// 	charge for the Source Code, or Executable Code, any
// 	Exploitation of the Source Code or Executable Code, or for any
// 	Derivative Works;
//   3.1.5 
// 	not to place any restrictions on the operability of the Source 
// 	Code;
//   3.1.6 
// 	to attach prominent notices to any Derivative Works stating
// 	that you have changed the Source Code or Executable Code and to
// 	include the details anddate of such change; and
//   3.1.7 
//   	not to Exploit the Source Code or Executable Code otherwise than
// 	as expressly permitted by  this Agreement.
// 



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "system.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int
	cdrom_finder_initialised = FALSE,
	number_of_cdrom_drives,
	cdrom_track_playing = -1,
	cdrom_track_repeat = FALSE,
	cdrom_audio_track_playing = FALSE,
//	cdrom_drives[32],
	cdrom_file_drive_index = -1;

SDL_CD
	*cdrom_drive = nullptr;


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void initialise_cdrom_finder ( void );

static int internal_play_cd_audio_track ( void *data );

//FIXME: not use or what? static long cdrom_notification_routine ( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initialise_cdrom_system ( void )
{
	if( !SDL_WasInit(SDL_INIT_CDROM) )
		SDL_InitSubSystem(SDL_INIT_CDROM);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int check_cdrom_file_exists ( char *filename )
{
//	Real code to find a CD in linux, but finding a CD is a very non-linux thing.
//	Give it any path, and the file system will be happy.
//
//	const char *CDNAME = SDL_CDName(0);
//	FILE *mupp = setmntent ("/proc/mounts", "r"); // /etc/mtab
//	struct mntent *chk = getmntent (FILE *stream);
//	if(0==strcmp( chk->mnt_fsname, CDNAME )) {
//		CDdir = mnt_dir;
//	}
//	endmntent(mupp);

	int
		count;

	char
		path[1024];

	if ( !cdrom_finder_initialised )
	{

		initialise_cdrom_finder ();
	}

	for ( count = 0; count < number_of_cdrom_drives; count++ )
	{


/*FIXME:	sprintf ( path, "%s/%s", cdrom_drives[count], filename );

		if ( file_exist ( path ) )
		{

			cdrom_file_drive_index = count;

			return ( cdrom_drives[count] );
		}
*/
	}

	return ( FALSE );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void initialise_cdrom_finder ( void )
{

	number_of_cdrom_drives = SDL_CDNumDrives();
	
	if ( number_of_cdrom_drives == 0 )
	{
		fprintf ( stderr, "No CDROM devices available\n");
	}

	cdrom_finder_initialised = TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static int
	cdrom_device_captured = FALSE;

//static UINT
char
	*cdrom_device_id = NULL;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int capture_cd_audio_device ( void )
{

	if ( cdrom_file_drive_index != -1 )
	{

		//
		// We found a CD drive which we want to use for music
		//

		cdrom_drive = SDL_CDOpen( cdrom_file_drive_index );
	}
	else
	{

		//
		// We haven't looked for a CD drive - use system default CD
		//

		cdrom_drive = SDL_CDOpen( 0 );
		
		if(cdrom_drive)
			cdrom_file_drive_index = 0;
	}

	if ( !CD_INDRIVE(SDL_CDStatus(cdrom_drive)) )
	{

		debug_log ( "Unable to capture cd audio: %s", SDL_GetError() );

		return ( FALSE );
	}
	else
	{

		//
		// Get the device ID.
		//

	//FIXME: assignment discards qualifiers from pointer target type
	//	cdrom_device_id = SDL_CDName( cdrom_file_drive_index );

		cdrom_device_captured = TRUE;

		register_exit_function ( release_cd_audio_device );

		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void release_cd_audio_device ( void )
{

	if ( cdrom_device_captured )
	{

		SDL_CDClose( cdrom_drive );

		cdrom_device_captured = FALSE;
	}
	
	SDL_QuitSubSystem(SDL_INIT_CDROM);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void play_cd_audio_track ( int track )
{

	cdrom_track_repeat = FALSE;

	cdrom_track_playing = track;

	system_thread_function ( internal_play_cd_audio_track, &track );

	cdrom_track_repeat = TRUE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void play_one_shot_cd_audio_track ( int track )
{

	cdrom_track_repeat = FALSE;

	cdrom_track_playing = track;

	system_thread_function ( internal_play_cd_audio_track, &track );

	cdrom_track_repeat = FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int internal_play_cd_audio_track ( void *data )
{

	int
		track;

	track = *( ( int * ) data );

	if ( cdrom_device_captured )
	{

		cdrom_audio_track_playing = TRUE;
		
		SDL_CDPlayTracks(cdrom_drive, 0, 0, track, 0);
		
		switch( SDL_CDStatus(cdrom_drive) )
		{
		case CD_TRAYEMPTY:
		case CD_ERROR:
			debug_log("CD audio error or tray empty");
			cdrom_audio_track_playing = FALSE;
			release_cd_audio_device ();
		}

	}

	return ( TRUE );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void pause_cd_audio ( void )
{

	if ( cdrom_device_captured )
	{

		if ( -1 == SDL_CDPause( cdrom_drive ) )
		{

			//
			// Ditch the cd player!
			//

			debug_log ( "Unable to pause cd" );

			release_cd_audio_device ();
		}
		
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void unpause_cd_audio ( void )
{

	if ( cdrom_device_captured )
	{

		if ( -1 == SDL_CDResume( cdrom_drive ) )
		{

			//
			// Ditch the cd player!
			//

			debug_log ( "Unable to pause cd" );

			release_cd_audio_device ();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void stop_cd_audio ( void )
{

	if ( cdrom_device_captured )
	{

		int
			value;
	
		cdrom_track_repeat = FALSE;

		value = SDL_CDStop( cdrom_drive );

		if ( value == -1 )
		{

			//
			// Ditch the cd player!
			//

			debug_log ( "Unable to stop cd" );

			release_cd_audio_device ();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int is_cd_audio_playing ( void )
{

	return ( cdrom_audio_track_playing );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

/*long cdrom_notification_routine ( void )
{
}*/

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int check_cd_for_80_minutes ( void )
{
/*
	if ( cdrom_device_captured )
	{

		int
			number_of_tracks,
			starting_position,
			track_length,
			total_cd_length,
			minute_cd_length,
			second_cd_length;

		MCI_STATUS_PARMS
			mciStatusParms;

		MCI_SET_PARMS
			set_parameters;
	
		//
		// Get the number of tracks; 
		//

		mciStatusParms.dwItem = MCI_STATUS_NUMBER_OF_TRACKS;

		if ( mciSendCommand ( cdrom_device_id, MCI_STATUS, MCI_STATUS_ITEM, (DWORD) (LPVOID) &mciStatusParms ) )
		{

			debug_log ( "Unable to get number of tracks on CD" );

			return ( FALSE );
		}

		number_of_tracks = mciStatusParms.dwReturn;

		//
		// Now change the format of the CD to milliseconds
		//

		//
		// Set the cdrom format to tracks/minutes/seconds/frames
		//

		set_parameters.dwTimeFormat = MCI_FORMAT_MILLISECONDS;

		if ( mciSendCommand ( cdrom_device_id, MCI_SET, MCI_SET_TIME_FORMAT, ( DWORD ) ( LPVOID ) &set_parameters ) )
		{

			debug_log ( "Unable to set the cd to milliseconds format" );

			return ( FALSE );
		}

		//
		// Get the starting position of the last track
		//

		mciStatusParms.dwItem = MCI_STATUS_POSITION;

		mciStatusParms.dwTrack = number_of_tracks;

		if ( mciSendCommand ( cdrom_device_id, MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK, ( DWORD ) ( LPVOID ) &mciStatusParms ) )
		{

			debug_log ( "Unable to get position of last track ( %d )", number_of_tracks );

			return ( FALSE );
		}

		starting_position = mciStatusParms.dwReturn;

		//
		// Get the length of the last track
		//

		mciStatusParms.dwItem = MCI_STATUS_LENGTH;

		mciStatusParms.dwTrack = number_of_tracks;

		if ( mciSendCommand ( cdrom_device_id, MCI_STATUS, MCI_STATUS_ITEM | MCI_TRACK, ( DWORD ) ( LPVOID ) &mciStatusParms ) )
		{

			debug_log ( "Unable to get length of last track ( %d )", number_of_tracks );

			return ( FALSE );
		}

		track_length = mciStatusParms.dwReturn;

		debug_log ( "Cd has %d tracks - last one starts at %d, and is %d long", number_of_tracks, starting_position, track_length );

		//
		// Set the cdrom format to tracks/minutes/seconds/frames
		//

		set_parameters.dwTimeFormat = MCI_FORMAT_TMSF;

		if ( mciSendCommand ( cdrom_device_id, MCI_SET, MCI_SET_TIME_FORMAT, ( DWORD ) ( LPVOID ) &set_parameters ) )
		{

			debug_log ( "Unable to set the CD back to tracks format" );
		}

		//
		// Now calculate the end time of the CD
		//

		total_cd_length = starting_position + track_length;

		total_cd_length /= 1000;

		minute_cd_length = total_cd_length / 60;

		second_cd_length = total_cd_length - ( minute_cd_length * 60 );

		debug_log ( "I figure the CD is %d minutes, %d seconds long", minute_cd_length, second_cd_length );

		if ( minute_cd_length >= 75 )
		{

			debug_log ( "Successful: %d minute long CD", total_cd_length );

			return ( TRUE );
		}
		else
		{
	
			debug_log ( "Failure: %d minute long CD", total_cd_length );

			return ( FALSE );
		}
	}
	else
	{

		return ( FALSE );
	}
*/
	return (TRUE);
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

