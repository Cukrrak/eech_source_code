// 
// 	 Enemy Engaged RAH-66 Comanche Versus KA-52 Hokum
// 	 Copyright (C) 2000 Empire Interactive (Europe) Ltd,
// 	 677 High Road, North Finchley, London N12 0DA
// 
// 	 Please see the document LICENSE.TXT for the full licence agreement
// 
// 2. LICENCE
//  2.1 	
//  	Subject to the provisions of this Agreement we now grant to you the 
//  	following rights in respect of the Source Code:
//   2.1.1 
//   	the non-exclusive right to Exploit  the Source Code and Executable 
//   	Code on any medium; and 
//   2.1.2 
//   	the non-exclusive right to create and distribute Derivative Works.
//  2.2 	
//  	Subject to the provisions of this Agreement we now grant you the
// 	following rights in respect of the Object Code:
//   2.2.1 
// 	the non-exclusive right to Exploit the Object Code on the same
// 	terms and conditions set out in clause 3, provided that any
// 	distribution is done so on the terms of this Agreement and is
// 	accompanied by the Source Code and Executable Code (as
// 	applicable).
// 
// 3. GENERAL OBLIGATIONS
//  3.1 
//  	In consideration of the licence granted in clause 2.1 you now agree:
//   3.1.1 
// 	that when you distribute the Source Code or Executable Code or
// 	any Derivative Works to Recipients you will also include the
// 	terms of this Agreement;
//   3.1.2 
// 	that when you make the Source Code, Executable Code or any
// 	Derivative Works ("Materials") available to download, you will
// 	ensure that Recipients must accept the terms of this Agreement
// 	before being allowed to download such Materials;
//   3.1.3 
// 	that by Exploiting the Source Code or Executable Code you may
// 	not impose any further restrictions on a Recipient's subsequent
// 	Exploitation of the Source Code or Executable Code other than
// 	those contained in the terms and conditions of this Agreement;
//   3.1.4 
// 	not (and not to allow any third party) to profit or make any
// 	charge for the Source Code, or Executable Code, any
// 	Exploitation of the Source Code or Executable Code, or for any
// 	Derivative Works;
//   3.1.5 
// 	not to place any restrictions on the operability of the Source 
// 	Code;
//   3.1.6 
// 	to attach prominent notices to any Derivative Works stating
// 	that you have changed the Source Code or Executable Code and to
// 	include the details anddate of such change; and
//   3.1.7 
//   	not to Exploit the Source Code or Executable Code otherwise than
// 	as expressly permitted by  this Agreement.
// 



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#include "system.h"

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#define MAX_NUMBER_TIMERS 16

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

struct TIMER_EVENT_STRUCT
{

	int
		used;

	UINT
		id;
};

typedef struct TIMER_EVENT_STRUCT timer_event_struct;

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

volatile int
	system_ticks;

int
	system_interrupt_timer_id,
	system_timer_id;

static int
	number_of_timers;

static timer_event_struct
	timer_list[MAX_NUMBER_TIMERS];

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void CALLBACK windows_timer_interrupt ( UINT	IDEvent, UINT	uReserved, DWORD	dwUser, DWORD dwReserved1, DWORD dwReserved2 );

static long windows_timer_routine ( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam );

static void deinitialise_timers_system ( void );

void windows_system_timer ( void );

void CALLBACK windows_system_timer_interrupt ( UINT	IDEvent, UINT	uReserved, DWORD	dwUser, DWORD dwReserved1, DWORD dwReserved2 );

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int initialise_timers_system (void)
{

	int
		count;

	MMRESULT
		result;

	TIMECAPS
		tc;

	system_ticks = 0;

	number_of_timers = 0;

	for ( count = 0; count < MAX_NUMBER_TIMERS; count++ )
	{

		timer_list[count].used = FALSE;

		timer_list[count].id = 0;
	}

	register_exit_function ( deinitialise_timers_system );

	register_system_message_function ( WM_TIMER, windows_timer_routine );

	timeGetDevCaps ( &tc, sizeof ( TIMECAPS ) );

	debug_log ( "Timer resolution: min: %d, max: %d", tc.wPeriodMin, tc.wPeriodMax );

	result = timeBeginPeriod ( 10 );

	if ( result == TIMERR_NOCANDO )
	{

		debug_log ( "Can't initialise the timer system" );

		return ( FALSE );
	}
	else
	{

		system_timer_id = 1;

		SetTimer ( application_window, system_timer_id, 100, NULL );


// DEBUG

//		system_interrupt_timer_id = timeSetEvent
//		(
//			10,
//			1,
//			windows_system_timer_interrupt,
//			0,
//			TIME_PERIODIC
//		);

// DEBUG
	
//		system_timer_id = create_timer_event ( 10, 1, windows_system_timer );
	
		return ( TRUE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void deinitialise_timers_system ( void )
{

	int
		count;

	for ( count = 0; count < number_of_timers; count++ )
	{

		if ( timer_list[count].used )
		{

			timeKillEvent ( timer_list[count].id );
		
			timer_list[count].used = FALSE;

			timer_list[count].id = 0;
		}
	}

	timeEndPeriod ( 10 );

//	if ( system_interrupt_timer_id )
//	{
//
//		timeKillEvent ( system_interrupt_timer_id );
//
//		system_interrupt_timer_id = 0;
//	}


	if ( system_timer_id )
	{

		KillTimer ( application_window, system_timer_id );

		system_timer_id = 0;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int create_timer_event ( UINT delay, UINT resolution, void ( *function ) ( void ) )
{

	int
		count,
		found;

	found = FALSE;

	for ( count = 0; ( ( count < MAX_NUMBER_TIMERS ) && ( !found ) ); count++ )
	{

		if ( !timer_list[count].used )
		{

			found = TRUE;
		}
	}

	if ( !found )
	{

		return ( FALSE );
	}

	timer_list[count].id = timeSetEvent ( delay, resolution, windows_timer_interrupt, (DWORD) function, TIME_PERIODIC );

	if ( timer_list[count].id )
	{

		timer_list[count].used = TRUE;

		number_of_timers++;

		debug_log ( "Created a timer" );

		return ( timer_list[count].id );
	}
	else
	{

		return ( FALSE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

int destroy_timer_event ( int timer_id )
{

	int
		count,
		found;

	found = FALSE;

	for ( count = 0; ( ( count < number_of_timers ) && ( !found ) ); count++ )
	{

		if ( ( timer_list[count].used ) && ( timer_list[count].id ) )
		{

			found = TRUE;
		}
	}

	if ( found )
	{

		timeKillEvent ( timer_list[count].id );

		timer_list[count].used = FALSE;

		return ( TRUE );
	}
	else
	{

		return ( FALSE );
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static void CALLBACK windows_timer_interrupt ( UINT IDEvent, UINT uReserved, DWORD dwUser, DWORD dwReserved1, DWORD dwReserved2 )
{

	void ( * function ) ( void );


	function = ( void ( * ) ( void ) ) dwUser;

	if ( ( !bExiting ) && ( application_active ) )
	{

		if ( function )
		{
	
			function ();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void windows_system_timer ( void )
{

	if ( !bExiting )
	{

		if ( application_active )
		{

			system_ticks +=10;
		}
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

static long windows_timer_routine ( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam )
{

	if ( !bExiting )
	{

		if ( application_active )
		{

			system_ticks += 10;
		}
	}

	return ( 0 );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void CALLBACK windows_system_timer_interrupt ( UINT IDEvent, UINT uReserved, DWORD dwUser, DWORD dwReserved1, DWORD dwReserved2 )
{

	if ( ( !bExiting ) && ( application_active ) )
	{

		system_ticks ++;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

void system_sleep ( int milliseconds )
{

	Sleep ( milliseconds );
}

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

